440. Backpack III 背包问题 III
完全背包
给定 n 种物品, 每种物品都有无限个. 第 i 个物品的体积为 A[i], 价值为 V[i].
再给定一个容量为 m 的背包. 问可以装入背包的最大价值是多少?
Given n kinds of items, and each kind of item has an infinite number available. The i-th item has size A[i] and value V[i].
Also given a backpack with size m. What is the maximum value you can put into the backpack?

样例
Example 1:

Input: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10
Output: 15
Explanation: Put three item 1 (A[1] = 3, V[1] = 5) into backpack.
Example 2:

Input: A = [1, 2, 3], V = [1, 2, 3], m = 5
Output: 5
Explanation: Strategy is not unique. For example, put five item 0 (A[0] = 1, V[0] = 1) into backpack.
注意事项
You cannot divide item into small pieces.
Total size of items you put into backpack can not exceed m.


解题思路：  dp[i][j] := 用前i个物品,size达到j的max value
           dp[i][j] = max(dp[i-1][j],    dp[i][j-A]+V)
                        没拿第i个物品    拿了第i个物品
                        
public class Solution {
    /**
     * @param A: an integer array
     * @param V: an integer array
     * @param m: An integer
     * @return: an array
     */
    public int backPackIII(int[] A, int[] V, int m) {
        // write your code here
        

        
        int n = A.length;
        int[][] dp = new int[n+1][m+1];
        for(int i = 1; i <= n; i++) {
            for (int j =1; j<=m;j++){
                dp[i][j]=dp[i-1][j]; 
                if(j >= A[i-1]) { // 包还有空
                    dp[i][j] = Math.max(dp[i][j], dp[i][j-A[i-1]]+V[i-1]);
                }
            }
        }
        return dp[n][m];
    }
}

空间优化：在原dp上直接改值
public class Solution {
    /**
     * @param A: an integer array
     * @param V: an integer array
     * @param m: An integer
     * @return: an array
     */
    public int backPackIII(int[] A, int[] V, int m) {
        // write your code here
   
        int n = A.length;
        int[] dp = new int[m+1];
        for(int i = 1; i <= n; i++) {
            for (int j =1; j<=m;j++){
                if(j >= A[i-1]) { 
                    dp[j] = Math.max(dp[j], dp[j - A[i-1]] + V[i-1]);
                }
            }
        }
        return dp[m];
    }
}
